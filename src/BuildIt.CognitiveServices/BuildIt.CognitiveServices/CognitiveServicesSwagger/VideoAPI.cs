// Code generated by Microsoft (R) AutoRest Code Generator 0.17.0.0
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.

namespace BuildIt.CognitiveServices
{
    using Microsoft.Rest;

    /// <summary>
    /// Welcome to the Microsoft Project Oxford Video API. Video API is a
    /// cloud-based API that provides advanced algorithms for tracking faces,
    /// detecting motion, and stabilizing video. These APIs allow you to
    /// build more personalized and intelligent apps by understanding and
    /// automatically transforming your video content.
    /// </summary>
    public partial class VideoAPI : Microsoft.Rest.ServiceClient<VideoAPI>, IVideoAPI
    {
        /// <summary>
        /// The base URI of the service.
        /// </summary>
        public System.Uri BaseUri { get; set; }

        /// <summary>
        /// Gets or sets json serialization settings.
        /// </summary>
        public Newtonsoft.Json.JsonSerializerSettings SerializationSettings { get; private set; }

        /// <summary>
        /// Gets or sets json deserialization settings.
        /// </summary>
        public Newtonsoft.Json.JsonSerializerSettings DeserializationSettings { get; private set; }

        /// <summary>
        /// Initializes a new instance of the VideoAPI class.
        /// </summary>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        public VideoAPI(params System.Net.Http.DelegatingHandler[] handlers) : base(handlers)
        {
            this.Initialize();
        }

        /// <summary>
        /// Initializes a new instance of the VideoAPI class.
        /// </summary>
        /// <param name='rootHandler'>
        /// Optional. The http client handler used to handle http transport.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        public VideoAPI(System.Net.Http.HttpClientHandler rootHandler, params System.Net.Http.DelegatingHandler[] handlers) : base(rootHandler, handlers)
        {
            this.Initialize();
        }

        /// <summary>
        /// Initializes a new instance of the VideoAPI class.
        /// </summary>
        /// <param name='baseUri'>
        /// Optional. The base URI of the service.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        public VideoAPI(System.Uri baseUri, params System.Net.Http.DelegatingHandler[] handlers) : this(handlers)
        {
            if (baseUri == null)
            {
                throw new System.ArgumentNullException("baseUri");
            }
            this.BaseUri = baseUri;
        }

        /// <summary>
        /// Initializes a new instance of the VideoAPI class.
        /// </summary>
        /// <param name='baseUri'>
        /// Optional. The base URI of the service.
        /// </param>
        /// <param name='rootHandler'>
        /// Optional. The http client handler used to handle http transport.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The delegating handlers to add to the http client pipeline.
        /// </param>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        public VideoAPI(System.Uri baseUri, System.Net.Http.HttpClientHandler rootHandler, params System.Net.Http.DelegatingHandler[] handlers) : this(rootHandler, handlers)
        {
            if (baseUri == null)
            {
                throw new System.ArgumentNullException("baseUri");
            }
            this.BaseUri = baseUri;
        }

        /// <summary>
        /// An optional partial-method to perform custom initialization.
        ///</summary> 
        partial void CustomInitialize();
        /// <summary>
        /// Initializes client properties.
        /// </summary>
        private void Initialize()
        {
            this.BaseUri = new System.Uri("https://westus.api.cognitive.microsoft.com/video/v1.0");
            SerializationSettings = new Newtonsoft.Json.JsonSerializerSettings
            {
                Formatting = Newtonsoft.Json.Formatting.Indented,
                DateFormatHandling = Newtonsoft.Json.DateFormatHandling.IsoDateFormat,
                DateTimeZoneHandling = Newtonsoft.Json.DateTimeZoneHandling.Utc,
                NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore,
                ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Serialize,
                ContractResolver = new Microsoft.Rest.Serialization.ReadOnlyJsonContractResolver(),
                Converters = new  System.Collections.Generic.List<Newtonsoft.Json.JsonConverter>
                    {
                        new Microsoft.Rest.Serialization.Iso8601TimeSpanConverter()
                    }
            };
            DeserializationSettings = new Newtonsoft.Json.JsonSerializerSettings
            {
                DateFormatHandling = Newtonsoft.Json.DateFormatHandling.IsoDateFormat,
                DateTimeZoneHandling = Newtonsoft.Json.DateTimeZoneHandling.Utc,
                NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore,
                ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Serialize,
                ContractResolver = new Microsoft.Rest.Serialization.ReadOnlyJsonContractResolver(),
                Converters = new System.Collections.Generic.List<Newtonsoft.Json.JsonConverter>
                    {
                        new Microsoft.Rest.Serialization.Iso8601TimeSpanConverter()
                    }
            };
            CustomInitialize();
        }    
        /// <summary>
        /// &lt;p&gt;Smooths and stabilizes a video.  &lt;br/&gt;&amp;bull;  The
        /// supported input video formats include MP4, MOV, and WMV. Video file size
        /// should be no larger than 100MB. &lt;br/&gt;&amp;bull;  Stabilization is
        /// optimized for small camera motions, with or without rolling shutter
        /// effects (e.g. holding a static camera, and walking with a slow speed).
        /// &lt;br/&gt;&amp;bull;  Both width and height of the input video must be
        /// even numbers. &lt;br/&gt;&amp;bull;  The resolution of the input video
        /// should be less than or equal to 2160P (4K, 3840 X 2160).
        /// &lt;br/&gt;&amp;bull; Output files are deleted after 24 hours.&lt;/p&gt;
        /// </summary>
        /// <param name='subscriptionKey'>
        /// subscription key in url
        /// </param>
        /// <param name='ocpApimSubscriptionKey'>
        /// subscription key in header
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="Microsoft.Rest.HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async System.Threading.Tasks.Task<Microsoft.Rest.HttpOperationResponse> StabilizationWithHttpMessagesAsync(string subscriptionKey = default(string), string ocpApimSubscriptionKey = default(string), System.Collections.Generic.Dictionary<string, System.Collections.Generic.List<string>> customHeaders = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Tracing
            bool _shouldTrace = Microsoft.Rest.ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = Microsoft.Rest.ServiceClientTracing.NextInvocationId.ToString();
                System.Collections.Generic.Dictionary<string, object> tracingParameters = new System.Collections.Generic.Dictionary<string, object>();
                tracingParameters.Add("subscriptionKey", subscriptionKey);
                tracingParameters.Add("ocpApimSubscriptionKey", ocpApimSubscriptionKey);
                tracingParameters.Add("cancellationToken", cancellationToken);
                Microsoft.Rest.ServiceClientTracing.Enter(_invocationId, this, "Stabilization", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "stabilize").ToString();
            System.Collections.Generic.List<string> _queryParameters = new System.Collections.Generic.List<string>();
            if (subscriptionKey != null)
            {
                _queryParameters.Add(string.Format("subscription-key={0}", System.Uri.EscapeDataString(subscriptionKey)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            System.Net.Http.HttpRequestMessage _httpRequest = new System.Net.Http.HttpRequestMessage();
            System.Net.Http.HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new System.Net.Http.HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (ocpApimSubscriptionKey != null)
            {
                if (_httpRequest.Headers.Contains("Ocp-Apim-Subscription-Key"))
                {
                    _httpRequest.Headers.Remove("Ocp-Apim-Subscription-Key");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Ocp-Apim-Subscription-Key", ocpApimSubscriptionKey);
            }
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Send Request
            if (_shouldTrace)
            {
                Microsoft.Rest.ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                Microsoft.Rest.ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            System.Net.HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 202 && (int)_statusCode != 400 && (int)_statusCode != 415 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 429)
            {
                var ex = new Microsoft.Rest.HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new Microsoft.Rest.HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new Microsoft.Rest.HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    Microsoft.Rest.ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new Microsoft.Rest.HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                Microsoft.Rest.ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Get operation result. If succeeded, this interface returns a JSON that
        /// includes time stamps and operation status. Below is an example:
        /// 
        /// Example JSON:
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;
        /// {&lt;br/&gt;
        /// "status": "Running",&lt;br/&gt;
        /// "createdDateTime":  "2015-09-30T01:28:23.4493273Z",&lt;br/&gt;
        /// "lastActionDateTime": "2015-09-30T01:32:23.0895791Z",&lt;br/&gt;
        /// }&lt;br/&gt;
        /// &lt;/tr&gt;
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// &lt;br/&gt;
        /// &lt;p&gt;
        /// Possible values of "status" field are:&lt;br/&gt;
        /// &lt;b&gt;Not Started&lt;/b&gt; - video content is received/uploaded but
        /// the process has not started.&lt;br/&gt;
        /// &lt;b&gt;Uploading&lt;/b&gt; - the video content is being uploaded by the
        /// URL client side provides.&lt;br/&gt;
        /// &lt;b&gt;Running&lt;/b&gt; - the process is running.&lt;br/&gt;
        /// &lt;b&gt;Failed&lt;/b&gt; - the process is failed. Detailed information
        /// will be provided in "message" field.&lt;br/&gt;
        /// &lt;b&gt;Succeeded&lt;/b&gt; - the process succeeded. In this case,
        /// depending on specific operation client side created, the result can be
        /// retrieved in following two ways:&lt;br/&gt;
        /// &lt;/p&gt;
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;tr&gt;&lt;th&gt;Video Operation&lt;/th&gt;&lt;th&gt;How to
        /// Retrieve Result&lt;/th&gt;&lt;/tr&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;&lt;td&gt;Stabilization&lt;/td&gt;&lt;td&gt;The
        /// result (as a video file) can be retrieved from the URL specified in
        /// &lt;b&gt;resourceLocation&lt;/b&gt; field.&lt;/td&gt;&lt;/tr&gt;
        /// &lt;tr&gt;&lt;td&gt;Face Detection and
        /// Tracking&lt;br/&gt;Motion Detection
        /// &lt;/td&gt;&lt;td&gt;The result (as a JSON in string) is available in
        /// &lt;b&gt;processingResult&lt;/b&gt; field.&lt;/td&gt;&lt;/tr&gt;
        /// &lt;/tbody&gt;
        /// &lt;/table&gt;
        /// </summary>
        /// <param name='oid'>
        /// OperationId
        /// </param>
        /// <param name='subscriptionKey'>
        /// subscription key in url
        /// </param>
        /// <param name='ocpApimSubscriptionKey'>
        /// subscription key in header
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="Microsoft.Rest.HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="Microsoft.Rest.ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async System.Threading.Tasks.Task<Microsoft.Rest.HttpOperationResponse> GetOperationResultWithHttpMessagesAsync(string oid, string subscriptionKey = default(string), string ocpApimSubscriptionKey = default(string), System.Collections.Generic.Dictionary<string, System.Collections.Generic.List<string>> customHeaders = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (oid == null)
            {
                throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.CannotBeNull, "oid");
            }
            // Tracing
            bool _shouldTrace = Microsoft.Rest.ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = Microsoft.Rest.ServiceClientTracing.NextInvocationId.ToString();
                System.Collections.Generic.Dictionary<string, object> tracingParameters = new System.Collections.Generic.Dictionary<string, object>();
                tracingParameters.Add("oid", oid);
                tracingParameters.Add("subscriptionKey", subscriptionKey);
                tracingParameters.Add("ocpApimSubscriptionKey", ocpApimSubscriptionKey);
                tracingParameters.Add("cancellationToken", cancellationToken);
                Microsoft.Rest.ServiceClientTracing.Enter(_invocationId, this, "GetOperationResult", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "operations/{oid}").ToString();
            _url = _url.Replace("{oid}", System.Uri.EscapeDataString(oid));
            System.Collections.Generic.List<string> _queryParameters = new System.Collections.Generic.List<string>();
            if (subscriptionKey != null)
            {
                _queryParameters.Add(string.Format("subscription-key={0}", System.Uri.EscapeDataString(subscriptionKey)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            System.Net.Http.HttpRequestMessage _httpRequest = new System.Net.Http.HttpRequestMessage();
            System.Net.Http.HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new System.Net.Http.HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (ocpApimSubscriptionKey != null)
            {
                if (_httpRequest.Headers.Contains("Ocp-Apim-Subscription-Key"))
                {
                    _httpRequest.Headers.Remove("Ocp-Apim-Subscription-Key");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Ocp-Apim-Subscription-Key", ocpApimSubscriptionKey);
            }
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Send Request
            if (_shouldTrace)
            {
                Microsoft.Rest.ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                Microsoft.Rest.ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            System.Net.HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 404 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 429)
            {
                var ex = new Microsoft.Rest.HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new Microsoft.Rest.HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new Microsoft.Rest.HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    Microsoft.Rest.ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new Microsoft.Rest.HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                Microsoft.Rest.ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// &lt;p&gt;Detects and tracks human faces in a video and returns face
        /// locations. &lt;br/&gt;&amp;bull; The supported input video formats
        /// include MP4, MOV, and WMV. Video file size should be no larger than
        /// 100MB. &lt;br/&gt;&amp;bull; The detectable face size range is 24x24 to
        /// 2048x2048 pixels. The faces out of this range will not be detected.
        /// &lt;br/&gt;&amp;bull; For each video, the maximum number of faces
        /// returned is 64. &lt;br/&gt;&amp;bull; Some faces may not be detected due
        /// to technical challenges; e.g. very large face angles (head-pose), and
        /// large occlusion. Frontal and near-frontal faces have the best results.
        /// &lt;br/&gt;&amp;bull; Output files are deleted after 24 hours.
        /// &lt;/p&gt;
        /// </summary>
        /// <param name='subscriptionKey'>
        /// subscription key in url
        /// </param>
        /// <param name='ocpApimSubscriptionKey'>
        /// subscription key in header
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="Microsoft.Rest.HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async System.Threading.Tasks.Task<Microsoft.Rest.HttpOperationResponse> FaceDetectionandTrackingWithHttpMessagesAsync(string subscriptionKey = default(string), string ocpApimSubscriptionKey = default(string), System.Collections.Generic.Dictionary<string, System.Collections.Generic.List<string>> customHeaders = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Tracing
            bool _shouldTrace = Microsoft.Rest.ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = Microsoft.Rest.ServiceClientTracing.NextInvocationId.ToString();
                System.Collections.Generic.Dictionary<string, object> tracingParameters = new System.Collections.Generic.Dictionary<string, object>();
                tracingParameters.Add("subscriptionKey", subscriptionKey);
                tracingParameters.Add("ocpApimSubscriptionKey", ocpApimSubscriptionKey);
                tracingParameters.Add("cancellationToken", cancellationToken);
                Microsoft.Rest.ServiceClientTracing.Enter(_invocationId, this, "FaceDetectionandTracking", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "trackface").ToString();
            System.Collections.Generic.List<string> _queryParameters = new System.Collections.Generic.List<string>();
            if (subscriptionKey != null)
            {
                _queryParameters.Add(string.Format("subscription-key={0}", System.Uri.EscapeDataString(subscriptionKey)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            System.Net.Http.HttpRequestMessage _httpRequest = new System.Net.Http.HttpRequestMessage();
            System.Net.Http.HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new System.Net.Http.HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (ocpApimSubscriptionKey != null)
            {
                if (_httpRequest.Headers.Contains("Ocp-Apim-Subscription-Key"))
                {
                    _httpRequest.Headers.Remove("Ocp-Apim-Subscription-Key");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Ocp-Apim-Subscription-Key", ocpApimSubscriptionKey);
            }
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Send Request
            if (_shouldTrace)
            {
                Microsoft.Rest.ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                Microsoft.Rest.ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            System.Net.HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 202 && (int)_statusCode != 400 && (int)_statusCode != 415 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 429)
            {
                var ex = new Microsoft.Rest.HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new Microsoft.Rest.HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new Microsoft.Rest.HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    Microsoft.Rest.ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new Microsoft.Rest.HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                Microsoft.Rest.ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// &lt;p&gt;Detects motion in a video, and returns the frame and duration of
        /// the motion that was captured. &lt;br/&gt;&amp;bull; The supported input
        /// video formats include MP4, MOV, and WMV. Video file size should be no
        /// larger than 100MB. &lt;br/&gt;&amp;bull; User can input detection zones
        /// to set up as areas to detect motion. &lt;br/&gt;&amp;bull; User can
        /// specify motion sensitivity: high, medium, and low. Higher sensitivity
        /// means more motions will be detected at a cost that more false alarms will
        /// be reported.&lt;br/&gt;&amp;bull; Motion Detection is optimized for
        /// stationary background videos. &lt;br/&gt;&amp;bull; User can specify
        /// whether light change events should be detected. A light change refers to
        /// a change in the frame that was caused by a light turning off and on. Some
        /// developers do not want to detect this, as they consider it a false alarm.
        /// Other developers want to make sure they capture any change, light changes
        /// included.&lt;br/&gt;&amp;bull; User can specify whether successive
        /// motions should be merged together by passing in a parameter
        /// (mergeTimeThreshold) For example, if a motion happens from 1 to 4 seconds
        /// and the next motion happens from 5 to 10 seconds, some developers will
        /// want to count that as one instance of motion.&lt;br/&gt;&amp;bull; User
        /// can specify which frames to be detected by passing in a parameter
        /// (frameSamplingValue).&lt;br/&gt;&amp;bull; Some motion may not be
        /// detected due to technical challenges; e.g. semi-transparent objects, and
        /// some small objects. &lt;br/&gt;&amp;bull; Output files are deleted after
        /// 24 hours.
        /// &lt;/p&gt;
        /// </summary>
        /// <param name='sensitivityLevel'>
        /// Specify the detection sensitivity level: “low”, “medium”, “high”. Higher
        /// sensitivity means more motions will be detected at a cost that more false
        /// alarms will be reported. The default value is “medium”.
        /// </param>
        /// <param name='frameSamplingValue'>
        /// User may skip frames by setting this parameter. It can be used as a
        /// tradeoff between performance and cost, skipping frames may reduce
        /// processing time but result in worse detection performance. The default
        /// value is 1, meaning detecting motion for every frame. If set to 2, then
        /// the algorithm will detect one frame for every two frames. The upper bound
        /// is 20.
        /// </param>
        /// <param name='detectionZones'>
        /// User can setup detection zones by passing in a string like
        /// “detectionZones=0,0;0.5,0;1,0;1,0.5;1,1;0.5,1;0,1;0,0.5
        /// |0.3,0.3;0.55,0.3;0.8,0.3; 0.8,0.55;0.8,0.8;0.55,0.8;0.3,0.8;0.3,0.55;|
        /// 0,0;1,0;1,1;0,1”, each detection zone is separated by a “|” and each
        /// point is defined by a “x,y” pair and separated by a “;”. At most 8
        /// detection zones are supported and each detection zone should be defined
        /// by at least 3 points and no more than 16 points. The default setting is
        /// “detectionZones=0,0;0.5,0;1,0;1,0.5;1,1;0.5,1;0,1;0,0.5”, i.e. the whole
        /// frame defined by an 8-point polygon.
        /// </param>
        /// <param name='detectLightChange'>
        /// Specify whether light change events should be detected. The default value
        /// is false.
        /// </param>
        /// <param name='mergeTimeThreshold'>
        /// Specify the threshold on whether successive motions should be merged
        /// together, if the interval between successive motions is &lt;=
        /// mergeTimeThreshold, they will be merged. The default value is 0.0 and
        /// upper bound is 10.0.
        /// </param>
        /// <param name='subscriptionKey'>
        /// subscription key in url
        /// </param>
        /// <param name='ocpApimSubscriptionKey'>
        /// subscription key in header
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="Microsoft.Rest.HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async System.Threading.Tasks.Task<Microsoft.Rest.HttpOperationResponse> MotionDetectionWithHttpMessagesAsync(string sensitivityLevel = default(string), double? frameSamplingValue = default(double?), string detectionZones = default(string), bool? detectLightChange = default(bool?), double? mergeTimeThreshold = default(double?), string subscriptionKey = default(string), string ocpApimSubscriptionKey = default(string), System.Collections.Generic.Dictionary<string, System.Collections.Generic.List<string>> customHeaders = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Tracing
            bool _shouldTrace = Microsoft.Rest.ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = Microsoft.Rest.ServiceClientTracing.NextInvocationId.ToString();
                System.Collections.Generic.Dictionary<string, object> tracingParameters = new System.Collections.Generic.Dictionary<string, object>();
                tracingParameters.Add("sensitivityLevel", sensitivityLevel);
                tracingParameters.Add("frameSamplingValue", frameSamplingValue);
                tracingParameters.Add("detectionZones", detectionZones);
                tracingParameters.Add("detectLightChange", detectLightChange);
                tracingParameters.Add("mergeTimeThreshold", mergeTimeThreshold);
                tracingParameters.Add("subscriptionKey", subscriptionKey);
                tracingParameters.Add("ocpApimSubscriptionKey", ocpApimSubscriptionKey);
                tracingParameters.Add("cancellationToken", cancellationToken);
                Microsoft.Rest.ServiceClientTracing.Enter(_invocationId, this, "MotionDetection", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "detectmotion").ToString();
            System.Collections.Generic.List<string> _queryParameters = new System.Collections.Generic.List<string>();
            if (sensitivityLevel != null)
            {
                _queryParameters.Add(string.Format("sensitivityLevel={0}", System.Uri.EscapeDataString(sensitivityLevel)));
            }
            if (frameSamplingValue != null)
            {
                _queryParameters.Add(string.Format("frameSamplingValue={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(frameSamplingValue, this.SerializationSettings).Trim('"'))));
            }
            if (detectionZones != null)
            {
                _queryParameters.Add(string.Format("detectionZones={0}", System.Uri.EscapeDataString(detectionZones)));
            }
            if (detectLightChange != null)
            {
                _queryParameters.Add(string.Format("detectLightChange={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(detectLightChange, this.SerializationSettings).Trim('"'))));
            }
            if (mergeTimeThreshold != null)
            {
                _queryParameters.Add(string.Format("mergeTimeThreshold={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(mergeTimeThreshold, this.SerializationSettings).Trim('"'))));
            }
            if (subscriptionKey != null)
            {
                _queryParameters.Add(string.Format("subscription-key={0}", System.Uri.EscapeDataString(subscriptionKey)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            System.Net.Http.HttpRequestMessage _httpRequest = new System.Net.Http.HttpRequestMessage();
            System.Net.Http.HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new System.Net.Http.HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (ocpApimSubscriptionKey != null)
            {
                if (_httpRequest.Headers.Contains("Ocp-Apim-Subscription-Key"))
                {
                    _httpRequest.Headers.Remove("Ocp-Apim-Subscription-Key");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Ocp-Apim-Subscription-Key", ocpApimSubscriptionKey);
            }
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Send Request
            if (_shouldTrace)
            {
                Microsoft.Rest.ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                Microsoft.Rest.ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            System.Net.HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 202 && (int)_statusCode != 400 && (int)_statusCode != 415 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 429)
            {
                var ex = new Microsoft.Rest.HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new Microsoft.Rest.HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new Microsoft.Rest.HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    Microsoft.Rest.ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new Microsoft.Rest.HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                Microsoft.Rest.ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// This interface is used for getting result video content. Currently only
        /// Stabilization outputs video content as result. The URL to this interface
        /// should be retrieved from &lt;b&gt;resourceLocation&lt;/b&gt; field of
        /// JSON returned from Get Operation Result interface.
        /// </summary>
        /// <param name='oid'>
        /// </param>
        /// <param name='subscriptionKey'>
        /// subscription key in url
        /// </param>
        /// <param name='ocpApimSubscriptionKey'>
        /// subscription key in header
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="Microsoft.Rest.HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="Microsoft.Rest.ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async System.Threading.Tasks.Task<Microsoft.Rest.HttpOperationResponse> GetResultVideoWithHttpMessagesAsync(string oid, string subscriptionKey = default(string), string ocpApimSubscriptionKey = default(string), System.Collections.Generic.Dictionary<string, System.Collections.Generic.List<string>> customHeaders = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (oid == null)
            {
                throw new Microsoft.Rest.ValidationException(Microsoft.Rest.ValidationRules.CannotBeNull, "oid");
            }
            // Tracing
            bool _shouldTrace = Microsoft.Rest.ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = Microsoft.Rest.ServiceClientTracing.NextInvocationId.ToString();
                System.Collections.Generic.Dictionary<string, object> tracingParameters = new System.Collections.Generic.Dictionary<string, object>();
                tracingParameters.Add("oid", oid);
                tracingParameters.Add("subscriptionKey", subscriptionKey);
                tracingParameters.Add("ocpApimSubscriptionKey", ocpApimSubscriptionKey);
                tracingParameters.Add("cancellationToken", cancellationToken);
                Microsoft.Rest.ServiceClientTracing.Enter(_invocationId, this, "GetResultVideo", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "operations/{oid}/content").ToString();
            _url = _url.Replace("{oid}", System.Uri.EscapeDataString(oid));
            System.Collections.Generic.List<string> _queryParameters = new System.Collections.Generic.List<string>();
            if (subscriptionKey != null)
            {
                _queryParameters.Add(string.Format("subscription-key={0}", System.Uri.EscapeDataString(subscriptionKey)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            System.Net.Http.HttpRequestMessage _httpRequest = new System.Net.Http.HttpRequestMessage();
            System.Net.Http.HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new System.Net.Http.HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (ocpApimSubscriptionKey != null)
            {
                if (_httpRequest.Headers.Contains("Ocp-Apim-Subscription-Key"))
                {
                    _httpRequest.Headers.Remove("Ocp-Apim-Subscription-Key");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Ocp-Apim-Subscription-Key", ocpApimSubscriptionKey);
            }
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Send Request
            if (_shouldTrace)
            {
                Microsoft.Rest.ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                Microsoft.Rest.ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            System.Net.HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200 && (int)_statusCode != 400 && (int)_statusCode != 404 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 429)
            {
                var ex = new Microsoft.Rest.HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new Microsoft.Rest.HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new Microsoft.Rest.HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    Microsoft.Rest.ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new Microsoft.Rest.HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                Microsoft.Rest.ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// Generates a motion thumbnail from a video. The Video Thumbnail API
        /// provides an automatic summary for videos to let people see a preview or
        /// snapshot quickly. Selection of scenes from a video create a preview in
        /// form of a short video. &lt;br/&gt;
        /// &amp;bull; The supported input video formats include MP4, MOV, and WMV.
        /// Video file size should be no larger than 100MB. &lt;br/&gt;
        /// &amp;bull; The number of scenes displayed in the thumbnail is either
        /// chosen by the user or defaults to the optimal duration supported by the
        /// Video API’s algorithm.&lt;br/&gt;
        /// &amp;bull; A scene is a collection of indexed frames. Scenes are mapped
        /// according to sequence in video. &lt;br/&gt;
        /// &amp;bull; Fade in/fade out effects are included in the thumbnail by
        /// default, but can be turned off by the user. &lt;br/&gt;
        /// &amp;bull; Audio is included by default, but can be turned off by the
        /// user. Pauses in audio are detected to divide video into coherent scenes
        /// and avoid breaking sentences of speech.&lt;br/&gt;
        /// &amp;bull; Output files are deleted after 24 hours.&lt;br/&gt;
        /// &lt;br/&gt;
        /// * Optimal Duration of Video Thumbnail Supported by Video API shown in
        /// table below.
        /// 
        /// &lt;table class="element table"&gt;
        /// &lt;thead&gt;
        /// &lt;/thead&gt;
        /// &lt;tbody&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;Motion Thumbnail&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;Video duration (d)&lt;/td&gt;
        /// &lt;td&gt;d &lt; 3min&lt;/td&gt;
        /// &lt;td&gt;3min &lt; d &lt; 15min&lt;/td&gt;
        /// &lt;td&gt;15min &lt; d &lt; 30min&lt;/td&gt;
        /// &lt;td&gt;30min &lt; d&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tr&gt;
        /// &lt;td&gt;Thumbnail duration&lt;/td&gt;
        /// &lt;td&gt;15sec (2-3 scenes)&lt;/td&gt;
        /// &lt;td&gt;30sec (3-5 scenes)&lt;/td&gt;
        /// &lt;td&gt;60sec (5-10 scenes)&lt;/td&gt;
        /// &lt;td&gt;90sec (10-15 scenes)&lt;/td&gt;
        /// &lt;/tr&gt;
        /// &lt;tbody&gt;
        /// &lt;/table&gt;
        /// </summary>
        /// <param name='maxMotionThumbnailDurationInSecs'>
        /// Specifies maximum duration of output video (in seconds). The default value
        /// is 0, which indicates the duration will be automatically decided by the
        /// algorithm.
        /// </param>
        /// <param name='outputAudio'>
        /// Indicates whether output video should include audio track. The default
        /// value is true.
        /// </param>
        /// <param name='fadeInFadeOut'>
        /// Indicates whether output video should have fade in/out effect during scene
        /// changes. The default value is true.
        /// </param>
        /// <param name='subscriptionKey'>
        /// subscription key in url
        /// </param>
        /// <param name='ocpApimSubscriptionKey'>
        /// subscription key in header
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="Microsoft.Rest.HttpOperationException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async System.Threading.Tasks.Task<Microsoft.Rest.HttpOperationResponse> ThumbnailWithHttpMessagesAsync(double? maxMotionThumbnailDurationInSecs = default(double?), bool? outputAudio = default(bool?), bool? fadeInFadeOut = default(bool?), string subscriptionKey = default(string), string ocpApimSubscriptionKey = default(string), System.Collections.Generic.Dictionary<string, System.Collections.Generic.List<string>> customHeaders = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Tracing
            bool _shouldTrace = Microsoft.Rest.ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = Microsoft.Rest.ServiceClientTracing.NextInvocationId.ToString();
                System.Collections.Generic.Dictionary<string, object> tracingParameters = new System.Collections.Generic.Dictionary<string, object>();
                tracingParameters.Add("maxMotionThumbnailDurationInSecs", maxMotionThumbnailDurationInSecs);
                tracingParameters.Add("outputAudio", outputAudio);
                tracingParameters.Add("fadeInFadeOut", fadeInFadeOut);
                tracingParameters.Add("subscriptionKey", subscriptionKey);
                tracingParameters.Add("ocpApimSubscriptionKey", ocpApimSubscriptionKey);
                tracingParameters.Add("cancellationToken", cancellationToken);
                Microsoft.Rest.ServiceClientTracing.Enter(_invocationId, this, "Thumbnail", tracingParameters);
            }
            // Construct URL
            var _baseUrl = this.BaseUri.AbsoluteUri;
            var _url = new System.Uri(new System.Uri(_baseUrl + (_baseUrl.EndsWith("/") ? "" : "/")), "generatethumbnail").ToString();
            System.Collections.Generic.List<string> _queryParameters = new System.Collections.Generic.List<string>();
            if (maxMotionThumbnailDurationInSecs != null)
            {
                _queryParameters.Add(string.Format("maxMotionThumbnailDurationInSecs={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(maxMotionThumbnailDurationInSecs, this.SerializationSettings).Trim('"'))));
            }
            if (outputAudio != null)
            {
                _queryParameters.Add(string.Format("outputAudio={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(outputAudio, this.SerializationSettings).Trim('"'))));
            }
            if (fadeInFadeOut != null)
            {
                _queryParameters.Add(string.Format("fadeInFadeOut={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(fadeInFadeOut, this.SerializationSettings).Trim('"'))));
            }
            if (subscriptionKey != null)
            {
                _queryParameters.Add(string.Format("subscription-key={0}", System.Uri.EscapeDataString(subscriptionKey)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            System.Net.Http.HttpRequestMessage _httpRequest = new System.Net.Http.HttpRequestMessage();
            System.Net.Http.HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new System.Net.Http.HttpMethod("POST");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (ocpApimSubscriptionKey != null)
            {
                if (_httpRequest.Headers.Contains("Ocp-Apim-Subscription-Key"))
                {
                    _httpRequest.Headers.Remove("Ocp-Apim-Subscription-Key");
                }
                _httpRequest.Headers.TryAddWithoutValidation("Ocp-Apim-Subscription-Key", ocpApimSubscriptionKey);
            }
            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Send Request
            if (_shouldTrace)
            {
                Microsoft.Rest.ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await this.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                Microsoft.Rest.ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            System.Net.HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 202 && (int)_statusCode != 400 && (int)_statusCode != 415 && (int)_statusCode != 401 && (int)_statusCode != 403 && (int)_statusCode != 429)
            {
                var ex = new Microsoft.Rest.HttpOperationException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                if (_httpResponse.Content != null) {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                }
                else {
                    _responseContent = string.Empty;
                }
                ex.Request = new Microsoft.Rest.HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new Microsoft.Rest.HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    Microsoft.Rest.ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new Microsoft.Rest.HttpOperationResponse();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            if (_shouldTrace)
            {
                Microsoft.Rest.ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

    }
}
